@page "/"
@using CatSdk.CryptoTypes;
@using CatSdk.Facade;
@using CatSdk.Symbol;
@using CatSdk.Symbol.Factory;
@using CatSdk.Utils;
@using NageXymSharpApps.Client.Models;
@using System.Text;
@using nagexymsharpweb.Excels;
@using nagexymsharpweb.Models;
@using System.ComponentModel
@using NageXymSharpApps.Client.Modules;
@using AntDesign
@inject IMessageService _message
@inject HttpClient httpClient
@inject IJSRuntime JSRuntime

@inject NotificationService _notice

<div>
    <Row Justify="start">
        <h2>@_title</h2>
    </Row>
    <Row Justify="start">
        <Paragraph Style="font-size:0.8rem;">
            Excelに記載されたアドレスに対してまとめて投げXYMを行うためのツールです。
            <br /> 1 から 3 STEPを順番に行うことで簡単に多人数に投げXYMすることができます。
            <br /><br />読込を行うExcelファイルはSYMBOLタウンリストのフォーマットを想定しています。
            <br /><Text Type="danger">SYMBOLタウンリストを使用する場合は画像や図形を削除してからお使い下さい。(※エラーになってしまうのでm(__)m)</Text>
            <br /><br />
            <a href="https://docs.google.com/spreadsheets/d/1X2AsmEOXpMlwZ9r6yA-2sqEfTBpFnst_nF1nXhZjLCk/edit#gid=0" target="_blank">SYMBOLタウンリストのリンクはこちら</a>
            <br /><br />
            さっそく始めてみましょう！
        </Paragraph>
    </Row>
    <div class="card-container">
        <Tabs @bind-ActiveKey="@_activeKey" Type="@TabType.Card" Style="margin-bottom:80px;">
            <TabPane Tab="Step 1" Key="1">
                <div style="display:flex;align-items: baseline;">
                    <Paragraph Style="font-size:1rem;font-weight:bold;">１．Excelファイルを読込みます。</Paragraph>
                </div>
                <Paragraph Style="font-size:0.8rem;;margin-top:0px;"><a href="https://github.com/villhell/nagexymsharp/tree/master/Excel" target="_blank">ファイルを持っていない方はこちらのリンクには加工済みのファイルがあるのでダウンロードしてください。</a><br />※testと書いてあるのはTestnet版です。</Paragraph>
                <InputFile id="fileInput" OnChange="@UploadFiles" hidden />
                <Upload Name="files" FileList="fileList">
                    <label class="ant-btn ant-btn-primary" for="fileInput">
                        <Icon Type="upload" />
                        Excel読込
                    </label>
                </Upload>
            </TabPane>
            <TabPane Tab="Step 2" Key="2">
                <div style="display:flex;align-items: baseline;">
                    <Paragraph Style="font-size:1rem;font-weight:bold;">２．Node URLを入力し、Checkボタンを押してアドレス/ネームスペースに対して送金できるかチェックします。</Paragraph>
                </div>
                <div style="font-size:0.8rem;margin-top:0px;margin-bottom:10px;">
                    <a href="https://symbolnodes.org/nodes/" target="_blank">メインネットノードリスト</a>
                    <Divider Type="DirectionVHType.Vertical" />
                    <a href="https://symbolnodes.org/nodes_testnet/" target="_blank">テストネットノードリスト</a>
                </div>
                <div style="margin-bottom: 5px;">
                    <Paragraph Style="font-size:0.8rem;margin:0px;">Node URL:</Paragraph><Input Placeholder="Please Input Node Url (ex: " @bind-Value="@_nodeUrl" />
                </div>
                <Button Type="@ButtonType.Primary" OnClick="@Check_Click">Check</Button>
            </TabPane>
            <TabPane Tab="Step 3" Key="3">
                <div style="display:flex;align-items: baseline;">
                    <Paragraph Style="font-size:1rem;font-weight:bold;"> ３．秘密鍵を入力してNage XYMボタンを押して下さい。</Paragraph>
                </div>
                <Paragraph Style="font-size:0.8rem;">
                    <Text Type="danger" Style="font-size:0.8rem;margin-top:0px;">※秘密鍵はトランザクションに署名するためにブラウザ上で使用します。サーバーに送信したり、ストレージに保存したりしません。</Text>
                </Paragraph>
                <div style="margin-bottom: 5px;">
                    <Paragraph Style="font-size:0.8rem;margin:0px;">秘密鍵:</Paragraph><Input Placeholder="Please Input Private Key" @bind-Value="@_privateKey" />
                </div>
                <div>
                    <Button type="@ButtonType.Primary" OnClick="@Send_Click">Nage XYM!</Button>
                </div>
            </TabPane>
        </Tabs>
    </div>
    <div class="card-container">
        <Table DataSource="@datas"
               PageSize="100"
               Loading=_loading
               Bordered>
            <PropertyColumn Property="c=>c.Check"></PropertyColumn>
            <PropertyColumn Property="c=>c.Name"></PropertyColumn>
            <PropertyColumn Property="c=>c.Twitter"></PropertyColumn>
            <PropertyColumn Property="c=>c.Namespace"></PropertyColumn>
            <PropertyColumn Property="c=>c.Address"></PropertyColumn>
        </Table>
    </div>
</div>

<style>
    [data-theme='compact'] .card-container .ant-tabs-card .ant-tabs-content,
    .card-container .ant-tabs-card .ant-tabs-content {
        height: 120px;
        margin-top: -16px;
    }

        [data-theme='compact'] .card-container .ant-tabs-card .ant-tabs-content .ant-tabs-tabpane,
        .card-container .ant-tabs-card .ant-tabs-content .ant-tabs-tabpane {
            background: #fff;
            padding: 16px;
        }

    [data-theme='compact'] .card-container .ant-tabs-card .ant-tabs-bar,
    .card-container .ant-tabs-card .ant-tabs-bar {
        border-color: #fff;
    }

        [data-theme='compact'] .card-container .ant-tabs-card .ant-tabs-bar .ant-tabs-tab,
        .card-container .ant-tabs-card .ant-tabs-bar .ant-tabs-tab {
            border-color: transparent;
            background: transparent;
        }

        [data-theme='compact'] .card-container .ant-tabs-card .ant-tabs-bar .ant-tabs-tab-active,
        .card-container .ant-tabs-card .ant-tabs-bar .ant-tabs-tab-active {
            border-color: #fff;
            background: #fff;
        }
</style>

@code {
    private string _activeKey { get; set; } = "1";
    private string _nodeUrl = "";
    private string _privateKey = string.Empty;
    private string _title = string.Empty;
    private string _subTitle = string.Empty;
    private List<DataItem> datas;
    private List<UploadFileItem> fileList = new List<UploadFileItem>();
    private bool _loading = false;
    private SssExtention _sss;
    protected override async void OnInitialized()
    {
        base.OnInitialized();
        _title = "Nage XYM Sharp";
        _subTitle = "一覧に表示されたアドレスに対してまとめて投げXYMを行うツールです！";
        datas = new List<DataItem>();

        // SSS Extentionを読込む
        var sssModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
            "import", "./js/sss-extention.js"
        );
        _sss = await sssModule.InvokeAsync<SssExtention>("getSssObject");

        StateHasChanged();
    }

    #region Excelファイル読込み
    /// <summary>
    /// Excelファイル読込み
    /// </summary>
    /// <param name="e"></param>
    /// <returns></returns>
    private async Task UploadFiles(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.GetMultipleFiles().First();

            var excelFileData = new byte[file.Size];
            await file.OpenReadStream(file.Size).ReadAsync(excelFileData);

            var tempFilePath = Path.GetTempFileName() + file.Name;

            // 拡張子をチェック
            if (!string.Equals(Path.GetExtension(file.Name), ".xlsx"))
            {
                await _message.Warning("拡張子が.xlsxではありません。");
                return;
            }

            using (var fs = File.Create(tempFilePath))
            using (var binaryWriter = new BinaryWriter(fs))
            {
                binaryWriter.Write(excelFileData);
            }
            // データクリア
            datas = new List<DataItem>();

            // ローディング開始
            _loading = true;

            StateHasChanged();

            var config = new MessageConfig
                {
                    Content = "Loading...",
                };
            await _message.Loading(config);

            // Excelファイル読込み
            ExcelManager excel = new ExcelManager(tempFilePath);
            datas = await excel.ReadExcelFileAsync();

            // ローディング終了
            _loading = false;
            StateHasChanged();
            config = new MessageConfig
                {
                    Content = "Loaded",
                    Duration = 2,
                };
            await _message.Success(config);

        }
        catch (Exception ex)
        {
            await _message.Error(ex.Message);
        }
        finally
        {
            // ローディング終了
            _loading = false;
            StateHasChanged();
        }
    }
    #endregion

    #region 一覧に表示されたアドレス/ネームスペースをチェックする
    /// <summary>
    /// 一覧に表示されたアドレス/ネームスペースをチェックする
    /// </summary>
    private async Task Check_Click()
    {
        // getActiveAddress
        _nodeUrl = await JSRuntime.InvokeAsync<string>("NageXymSharpApps.GetActiveNode", new object[] { _sss.activeNetworkType });
        _nodeUrl = Utils.TrimingLastSlash(_nodeUrl);

        // Azureでデプロイするとhttpsになるので3000は使えない
        var port = new Uri(_nodeUrl).Port;
        if (port != 3001)
        {
            await _message.Warning("ポート3001に対応したノードを指定して下さい。");
            return;
        }
        // 一覧に何も表示されていなければ以降の処理を行わない
        if (datas.Count == 0)
        {
            await _message.Warning("Excelファイルを読み込んでください。");
            return;
        }

        // ノードが入力されていなければ以降の処理を行わない
        if (string.IsNullOrEmpty(_nodeUrl))
        {
            await _message.Warning("ノードのURLを指定して下さい。");
            return;
        }

        try
        {
            // ローディング開始
            string key = $"updatable-{DateTime.Now.Ticks}";
            var config = new MessageConfig
                {
                    Content = "Checking...",
                };
            await _message.Loading(config);

            //StateHasChanged();

            // グリッドを一行ずつ読んでいく
            foreach (var row in datas)
            {
                // CheckがOKならスキップ
                if (string.Equals(row.Check, "OK")) continue;

                StateHasChanged();

                // アドレス欄が空白
                if (string.IsNullOrEmpty(row.Address))
                {
                    // NGを設定して次の行へ
                    row.Check = "NG";
                    continue;
                }

                // アドレス情報取得
                var addressResponse = await Utils.GetAddressAsync(row.Address, httpClient, _nodeUrl);
                if (addressResponse != null)
                {
                    // アドレス情報取得成功

                    // 受信制限があるか
                    var isRestrictionsAccount = await Utils.IsRestrictionAccountAsync(row.Address, httpClient, _nodeUrl);
                    if (!isRestrictionsAccount)
                    {
                        // 受信制限なし
                        row.Check = "OK";
                    }
                    else
                    {
                        // 受信制限あり
                        row.Check = "Restricted reception";
                    }

                    // 次の行へ
                    continue;
                }

                // アドレス情報が取得できなければネームスペース情報を取得
                var namespaceResponse = await Utils.GetNamespaceAsync(row.Address, httpClient, _nodeUrl);
                if (namespaceResponse != null)
                {
                    // ネームスペース情報取得成功
                    var address = namespaceResponse.Namespace.Alias.Address ?? namespaceResponse.Namespace.OwnerAddress;
                    address = Converter.AddressToString(Converter.HexToBytes(address));

                    // 受信制限があるか
                    var isRestrictionsAccount = await Utils.IsRestrictionAccountAsync(address, httpClient, _nodeUrl);
                    if (!isRestrictionsAccount)
                    {
                        // 受信制限なし
                        row.Check = "OK";
                    }
                    else
                    {
                        // 受信制限あり
                        row.Check = "Restricted reception";
                    }

                    // row.Check = "OK";
                    row.Namespace = row.Address;
                    row.Address = address;
                }
            }

            StateHasChanged();

            await _message.Success(new MessageConfig
                {
                    Content = "Complete!",
                    Duration = 2
                });
        }
        catch (Exception ex)
        {
            await _message.Error(ex.Message);
        }
        finally
        {
            // ローディング終了
            _loading = false;
            StateHasChanged();
        }
    }
    #endregion

    #region Nage XYMボタンクリック
    /// <summary>
    /// Nage XYMボタンクリック
    /// </summary>
    /// <returns></returns>
    private async Task Send_Click()
    {
        _nodeUrl = Utils.TrimingLastSlash(_nodeUrl);

        try
        {
            // getActiveAddress
            _nodeUrl = await JSRuntime.InvokeAsync<string>("NageXymSharpApps.GetActiveNode", new object[] { _sss.activeNetworkType });

            // ネットワーク情報を取得
            var networkInfo = await Utils.GetNetworkInfo(_nodeUrl, httpClient);

            // ネットワーク情報が正しく取得できなかった
            if (networkInfo == null)
            {
                await _message.Warning("ネットワーク情報が取得できませんでした。処理を中断します。");
                return;
            }

            var network = string.Equals(networkInfo!.Name, "mainnet") ? CatSdk.Symbol.Network.MainNet : CatSdk.Symbol.Network.TestNet;
            var facade = new SymbolFacade(network);
            var privateKey = new PrivateKey(_privateKey);
            var publicKey = new PublicKey(Converter.HexToBytes(_sss.activePublicKey));
            var txs = new List<IBaseTransaction>();

            // グリッドの内容からトランザクションを生成
            foreach (var item in datas)
            {
                // Check列未入力の場合
                if (string.IsNullOrEmpty(item.Check))
                {
                    await _message.Warning("チェック済みでないデータがあるため処理を中断します。");
                    return;
                }

                // NGの場合は無視して次の行へ
                if (string.Equals(item.Check, "NG")) continue;

                // XYMをulongに変換、divisibility分を乗算
                var xym = (ulong)(item.Xym * 1000000);
                txs.Add(CreateTransaction(network, publicKey, item.Address, xym, Converter.Utf8ToPlainMessage(item.Message)));

                if (txs.Count > 99)
                {
                    await AnnounceAsync(network, facade, publicKey, txs);
                    txs.Clear();
                }
            }

            // 残ったトランザクションをアナウンス
            if (txs.Count > 0) await AnnounceAsync(network, facade, publicKey, txs);
        }
        catch (Exception ex)
        {
            await _message.Error(ex.Message);
        }
        finally
        {

        }
    }
    #endregion

    #region トランザクションを作成
    /// <summary>
    /// トランザクションを作成
    /// </summary>
    /// <param name="network"></param>
    /// <param name="publicKey"></param>
    /// <param name="address"></param>
    /// <param name="xym"></param>
    /// <param name="message"></param>
    /// <returns></returns>
    private EmbeddedTransferTransactionV1 CreateTransaction(Network network, PublicKey publicKey, string address, ulong xym, byte[] message)
    {
        var networkType = string.Equals(network.Name, "mainnet") ? NetworkType.MAINNET : NetworkType.TESTNET;
        ulong mosaicId = (ulong)(string.Equals(network.Name, "mainnet") ? 0x6BED913FA20223F8 : 0x72C0212E67A08BCE);
        return new EmbeddedTransferTransactionV1
            {
                Network = networkType,
                SignerPublicKey = publicKey,
                RecipientAddress = new UnresolvedAddress(Converter.StringToAddress(address)),
                Mosaics = new UnresolvedMosaic[]
                    {
                    new()
                    {
                        MosaicId = new UnresolvedMosaicId(mosaicId),
                        Amount = new Amount(xym)
                    }
                    },
                Message = message
            };
    }
    #endregion

    #region トランザクションをアナウンスする
    /// <summary>
    /// トランザクションをアナウンスする
    /// </summary>
    /// <param name="network"></param>
    /// <param name="facade"></param>
    /// <param name="publicKey"></param>
    /// <param name="txs"></param>
    /// <returns></returns>
    private async Task AnnounceAsync(Network network, SymbolFacade facade, PublicKey publicKey, List<IBaseTransaction> txs)
    {
        var innerTransactions = txs.ToArray();

        var merkleHash = SymbolFacade.HashEmbeddedTransactions(innerTransactions);

        // 手数料を取得
        var feeInfo = await Utils.GetTransactionFee(_nodeUrl, httpClient);
        var feeMultiplier = Utils.CalcFee(feeInfo.MinFeeMultiplier, feeInfo.AverageFeeMultiplier);

        var aggTx = new AggregateCompleteTransactionV2
            {
                Network = string.Equals(network.Name, "mainnet") ? NetworkType.MAINNET : NetworkType.TESTNET,
                Transactions = innerTransactions,
                SignerPublicKey = publicKey,
                //Fee = new Amount(feeMultiplier),
                TransactionsHash = merkleHash,
                Deadline = new Timestamp(facade.Network.FromDatetime<NetworkTimestamp>(DateTime.UtcNow).AddHours(2).Timestamp),
            };
        var fee = aggTx.Size * feeMultiplier;
        aggTx.Fee = new Amount((ulong)fee);

        var payload = TransactionsFactory.CreatePayload(aggTx);

        try
        {
            await JSRuntime.InvokeAsync<string>("NageXymSharpApps.SetTransactionByPayload", new object[] { payload });
        }
        catch (Exception ex)
        {
            await _notice.Open(new NotificationConfig()
                {
                    Message = "ERROR",
                    Description = ex.Message
                });
        }
        finally
        {
            await Task.Delay(4000);
        }
    }
    #endregion

    #region SSSにて署名を行った後のトランザクションペイロードを受け取る
    /// <summary>
    /// SSSにて署名を行った後のトランザクションペイロードを受け取る
    /// </summary>
    /// <param name="signedTxPayload"></param>
    [JSInvokable]
    public async Task GetSignedTransaction(string signedTxPayload)
    {
        if (string.IsNullOrEmpty(signedTxPayload))
        {
            Console.WriteLine(signedTxPayload);
            return;
        }
        
        var ms = new MemoryStream(Converter.HexToBytes(signedTxPayload));
        var br = new BinaryReader(ms);
        var aggTx = AggregateCompleteTransactionV2.Deserialize(br);

        var payload = TransactionsFactory.CreatePayload(aggTx);

        try
        {
            // トランザクションをアナウンス
            var responseDetailJson = await Utils.AnnounceTransactionAsync(payload, _nodeUrl, httpClient);

            // Messageがなければエラー。もしくはデシリアライズに失敗した場合もエラー
            Console.WriteLine(responseDetailJson.Message);

        }
        catch (Exception ex)
        {
            await _notice.Open(new NotificationConfig()
                {
                    Message = "ERROR",
                    Description = ex.Message
                });
        }
    }
    #endregion
}