@page "/nagexym"
@using CatSdk.CryptoTypes;
@using CatSdk.Facade;
@using CatSdk.Symbol;
@using CatSdk.Symbol.Factory;
@using CatSdk.Utils;
@using NageXymSharpApps.Client.Models;
@using System.Text;
@using nagexymsharpweb.Excels;
@using nagexymsharpweb.Models;
@using System.ComponentModel
@using NageXymSharpApps.Client.Modules;
@using AntDesign
@inject IMessageService _message
@inject HttpClient httpClient
@inject IJSRuntime JSRuntime

@inject NotificationService _notice

<div>

    <h1>@_title</h1>
    <Space Direction="DirectionVHType.Vertical">
        <SpaceItem Style="display:flex;margin-left:1px;">
            <InputFile id="fileInput" OnChange="@UploadFiles" hidden multiple />
            <Upload Name="files" FileList="fileList">
            <label class="ant-btn" for="fileInput">
                <Icon Type="upload" />
                Upload Excel file
            </label>
            </Upload>
            <Button Type="@ButtonType.Primary" OnClick="@Check_Click">Check</Button>
        </SpaceItem>
        <SpaceItem Style="display:flex;margin-left:1px;">
            Node URL: 
        </SpaceItem>
        <SpaceItem Style="display:flex;margin-left:1px;">
            <Input Placeholder="Please Input Node Url (ex: " @bind-Value="@_nodeUrl" OnBlur="@NodeUrl_Change"/>
        </SpaceItem>
        <SpaceItem>
            Private Key:
        </SpaceItem>
        <SpaceItem Style="display:flex;margin-left:1px;">
            <Input Placeholder="Please Input Private Key" @bind-Value="@_privateKey" />
            <Button type="@ButtonType.Primary" OnClick="@Send_Click">Nage XYM!</Button>
        </SpaceItem>
    </Space>
    
    <Divider></Divider>

    <Table
        DataSource="@datas"
        PageSize="100"
        Loading=_loading
        Bordered>
        <PropertyColumn Property="c=>c.Check" ></PropertyColumn>
        <PropertyColumn Property="c=>c.Name"></PropertyColumn>
        <PropertyColumn Property="c=>c.Twitter"></PropertyColumn>
        <PropertyColumn Property="c=>c.Namespace"></PropertyColumn>
        <PropertyColumn Property="c=>c.Address"></PropertyColumn>
    </Table>
</div>


@code {


    private string _port = ":3000";
    private string _prefix = "http://";
    private string _nodeUrl = "http://sym-test-01.opening-line.jp:3000";
    //private string _nodeUrl = "http://160.248.184.223:3000";
    private string _privateKey = string.Empty;
    private string _title = string.Empty;
    private string _subTitle = string.Empty;
    private string _network = "unknown";
    private List<DataItem> datas;
    private List<UploadFileItem> fileList = new List<UploadFileItem>();
    private bool _loading = false;

    protected override async void OnInitialized()
    {
        base.OnInitialized();
        _title = "nagexymsharp";
        _subTitle = "一覧に表示されたアドレスに対してまとめて投げXYMを行うツールです！";
        datas = new List<DataItem>();

        StateHasChanged();
    }

    private async Task NodeUrl_Change()
    {
        _nodeUrl = await Utils.GetNetworkInfo(_nodeUrl, httpClient);
    }

    private async Task UploadFiles(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.GetMultipleFiles().First();

            var excelFileData = new byte[file.Size];
            await file.OpenReadStream(file.Size).ReadAsync(excelFileData);

            var tempFilePath = Path.GetTempFileName() + file.Name;

            // 拡張子をチェック
            if (!string.Equals(Path.GetExtension(file.Name), ".xlsx"))
            {
                await _message.Warning("拡張子が.xlsxではありません。");
                return;
            }

            using (var fs = File.Create(tempFilePath))
            using (var binaryWriter = new BinaryWriter(fs))
            {
                binaryWriter.Write(excelFileData);
            }
            // データクリア
            datas = new List<DataItem>();

            // ローディング開始
            _loading = true;
            StateHasChanged();

            var config = new MessageConfig
            {
                Content = "Loading...",
            };
            await _message.Loading(config);

            // Excelファイル読込み
            ExcelManager excel = new ExcelManager(tempFilePath);
            datas = await excel.ReadExcelFileAsync();

            // ローディング終了
            _loading = false;
            StateHasChanged();
            config = new MessageConfig
            {
                Content = "Loaded",
                Duration = 2,
            };
            await _message.Success(config);

        }
        catch(Exception ex)
        {
            await _message.Error(ex.Message);
        }
        finally
        {
            // ローディング終了
            _loading = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// 一覧に表示されたアドレス/ネームスペースをチェックする
    /// </summary>
    private async Task Check_Click()
    {
        // 一覧に何も表示されていなければ以降の処理を行わない
        if (datas.Count == 0)
        {
            await _message.Warning("Excelファイルを読み込んでください。");
            return;
        }

        // ノードが入力されていなければ以降の処理を行わない
        if (string.IsNullOrEmpty(_nodeUrl))
        {
            await _message.Warning("ノードのURLを指定して下さい。");
            return;
        }

        // グリッドを一行ずつ読んでいく
        foreach(var row in datas)
        {
            StateHasChanged();

            // アドレス欄が空白
            if (string.IsNullOrEmpty(row.Address))
            {
                // NGを設定して次の行へ
                row.Check = "NG";
                continue;
            }

            // アドレス情報取得
            var addressResponse = await Utils.GetAddressAsync(row.Address, httpClient, _nodeUrl);
            if (addressResponse != null)
            {
                // アドレス情報取得成功

                // 受信制限があるか
                var isRestrictionsAccount = await Utils.IsRestrictionAccountAsync(row.Address, httpClient, _nodeUrl);
                if (!isRestrictionsAccount)
                {
                    // 受信制限なし
                    row.Check = "OK";
                }
                else
                {
                    // 受信制限あり
                    row.Check = "Restricted reception";
                }

                // 次の行へ
                continue;
            }

            // アドレス情報が取得できなければネームスペース情報を取得
            var namespaceResponse = await Utils.GetNamespaceAsync(row.Address, httpClient, _nodeUrl);
            if(namespaceResponse != null)
            {
                // ネームスペース情報取得成功
                var address = namespaceResponse.Namespace.Alias.Address ?? namespaceResponse.Namespace.OwnerAddress;
                address = Converter.AddressToString(Converter.HexToBytes(address));

                // 受信制限があるか
                var isRestrictionsAccount = await Utils.IsRestrictionAccountAsync(address, httpClient, _nodeUrl);
                if (!isRestrictionsAccount)
                {
                    // 受信制限なし
                    row.Check = "OK";
                }
                else
                {
                    // 受信制限あり
                    row.Check = "Restricted reception";
                }

                // row.Check = "OK";
                row.Namespace = row.Address;
                row.Address = address;
            }
        }

    }

    private async Task Send_Click()
    {

        _nodeUrl = Utils.TrimingLastSlash(_nodeUrl);
        // debug testnet only
        var network = 152 == 104 ? CatSdk.Symbol.Network.MainNet : CatSdk.Symbol.Network.TestNet;
        var facade = new SymbolFacade(network);
        var privateKey = new PrivateKey(_privateKey);
        var keyPair = new KeyPair(privateKey);
        var txs = new List<IBaseTransaction>();

        // グリッドの内容からトランザクションを生成
        foreach(var item in datas)
        {
            // Check列未入力の場合
            if (string.IsNullOrEmpty(item.Check))
            {
                await _message.Warning("チェック済みでないデータがあるため処理を中断します。");
                return;
            }

            // NGの場合は無視して次の行へ
            if (string.Equals(item.Check, "NG")) continue;

            // XYMをulongに変換、divisibility分を乗算
            var xym = (ulong)(item.Xym * 1000000);
            txs.Add(CreateTransaction(network, keyPair, item.Address, xym, Converter.Utf8ToPlainMessage(item.Message)));

            if(txs.Count > 99)
            {
                await AnnounceAsync(network, facade, keyPair, txs, (ulong)100);
                txs.Clear();
            }
        }

        // 残ったトランザクションをアナウンス
        if (txs.Count > 0) await AnnounceAsync(network, facade, keyPair, txs, (ulong)100);
    }

    #region トランザクションを作成
    /// <summary>
    /// トランザクションを作成
    /// </summary>
    /// <param name="network"></param>
    /// <param name="publicKey"></param>
    /// <param name="address"></param>
    /// <param name="xym"></param>
    /// <param name="message"></param>
    /// <returns></returns>
    private EmbeddedTransferTransactionV1 CreateTransaction(Network network, KeyPair keyPair, string address, ulong xym, byte[] message)
    {
        var networkType = string.Equals(network.Name, "mainnet") ? NetworkType.MAINNET : NetworkType.TESTNET;
        ulong mosaicId = (ulong)(string.Equals(network.Name, "mainnet") ? 0x6BED913FA20223F8 : 0x72C0212E67A08BCE);
        return new EmbeddedTransferTransactionV1
            {
                Network = networkType,
                SignerPublicKey = keyPair.PublicKey,
                RecipientAddress = new UnresolvedAddress(Converter.StringToAddress(address)),
                Mosaics = new UnresolvedMosaic[]
                {
                    new()
                    {
                        MosaicId = new UnresolvedMosaicId(mosaicId),
                        Amount = new Amount(xym)
                    }
                },
                Message = message
            };
    }
    #endregion

    #region トランザクションをアナウンスする
    /// <summary>
    /// トランザクションをアナウンスする
    /// </summary>
    /// <param name="network"></param>
    /// <param name="facade"></param>
    /// <param name="publicKey"></param>
    /// <param name="txs"></param>
    /// <returns></returns>
    private async Task AnnounceAsync(Network network, SymbolFacade facade, KeyPair keyPair, List<IBaseTransaction> txs, ulong feeMultiplier)
    {
        var innerTransactions = txs.ToArray();

        var merkleHash = SymbolFacade.HashEmbeddedTransactions(innerTransactions);

        var aggTx = new AggregateCompleteTransactionV2
        {
            Network = string.Equals(network.Name, "mainnet") ? NetworkType.MAINNET : NetworkType.TESTNET,
            Transactions = innerTransactions,
            SignerPublicKey = keyPair.PublicKey,
            Fee = new Amount(feeMultiplier),
            TransactionsHash = merkleHash,
            Deadline = new Timestamp(facade.Network.FromDatetime<NetworkTimestamp>(DateTime.UtcNow).AddHours(2).Timestamp),
        };
        var fee = aggTx.Size * feeMultiplier;
        aggTx.Fee = new Amount((ulong)fee);

        var signature = facade.SignTransaction(keyPair, aggTx);
        TransactionsFactory.AttachSignature(aggTx, signature);

        var payload = TransactionsFactory.CreatePayload(aggTx);

        try
        {
            

            //// サイン済みのペイロードからアグリゲートコンプリートトランザクション生成
            //var ms = new MemoryStream(Converter.HexToBytes(signedTx.payload));
            //var br = new BinaryReader(ms);
            //aggTx = AggregateCompleteTransactionV2.Deserialize(br);

            //// ペイロードを生成{ "payload" : "0E73...."}
            //payload = TransactionsFactory.CreatePayload(aggTx);

            var content = new StringContent(payload, Encoding.UTF8, "application/json");
            var response = await httpClient.PutAsync(_nodeUrl + "/transactions", content);
            var responseDetailsJson = await response.Content.ReadAsStringAsync();
            Console.WriteLine(responseDetailsJson);

        }
        catch (Exception ex)
        {
            await _notice.Open(new NotificationConfig()
            {
                Message = "ERROR",
                Description = ex.Message
            });
        }
        finally
        {
            await Task.Delay(4000);
        }
    }
    #endregion


}